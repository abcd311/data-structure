#include <iostream>
#include <algorithm> // For std::max

using namespace std;

template <typename T>
class AVLTree {
private:
    struct Node {
        T data;
        Node* left;
        Node* right;
        int ht; // Node height

        Node(const T& val) : data(val), left(nullptr), right(nullptr), ht(1) {}
    };

    Node* root;

protected:    
    // Get the height of a node
    int height(const Node* v) const {
        return (v == nullptr ? 0 : v->ht);
    }

    // Set the height of a node
    void setHeight(Node* v) {
        if (v != nullptr) {
            int hl = height(v->left);
            int hr = height(v->right);
            v->ht = 1 + std::max(hl, hr);
        }
    }

    // Check if a node is balanced
    bool isBalanced(const Node* v) const {
        if (v == nullptr) 
            return true;
        int bal = height(v->left) - height(v->right);
        return ((-1 <= bal) && (bal <= 1));
    }

    // Get the tallest child of a node
    Node* tallChild(Node* z) const {
        Node* zl = z->left;
        Node* zr = z->right;
        if (height(zl) >= height(zr)) 
            return zl;
        else 
            return zr;
    }

    // Get the tallest grandchild of a node
    Node* tallGrandchild(Node* z) const {
        Node* y = tallChild(z);
        // The tallest grandchild is the tallest child of the tallest child
        return tallChild(y);
    }

    // Perform a trinode restructuring (rotation)
    Node* restructure(Node* x, Node* y, Node* z) {
        // Perform the appropriate single or double rotation
        if (z->left == y && y->left == x) { // Left-Left Case
            z->left = y->right;
            y->right = z;
            setHeight(z);
            setHeight(y);
            return y;
        }
        if (z->right == y && y->right == x) { // Right-Right Case
            z->right = y->left;
            y->left = z;
            setHeight(z);
            setHeight(y);
            return y;
        }
        if (z->left == y && y->right == x) { // Left-Right Case
            y->right = x->left;
            z->left = x->right;
            x->left = y;
            x->right = z;
            setHeight(y);
            setHeight(z);
            setHeight(x);
            return x;
        }
        // Right-Left Case (z->right == y && y->left == x)
        y->left = x->right;
        z->right = x->left;
        x->right = y;
        x->left = z;
        setHeight(y);
        setHeight(z);
        setHeight(x);
        return x;
    }


    // Rebalance the tree starting from a node v and going up
    void rebalance(Node* z) {
        while (z != nullptr) {
            setHeight(z);
            if (!isBalanced(z)) {
                Node* y = tallChild(z);
                Node* x = tallChild(y);
                z = restructure(x, y, z);
            }
            if (z->parent != nullptr) { 
               // In a simple implementation, rebalancing is done on the recursion path
            } else {
               root = z; // Update root if it changed
               break;
            }
        }
    }
    
    // Recursive insert function
    Node* insert(Node* node, const T& val) {
        if (node == nullptr) {
            return new Node(val);
        }

        if (val < node->data) {
            node->left = insert(node->left, val);
        } else if (val > node->data) {
            node->right = insert(node->right, val);
        } else {
            return node; // Duplicate keys not handled
        }

        // Rebalance after insertion
        setHeight(node);
        if (!isBalanced(node)) {
            Node* y = tallChild(node);
            Node* x = tallChild(y);
            node = restructure(x, y, node);
        }
        return node;
    }


    // Recursive search function
    bool search(const Node* node, const T& val) const {
        if (node == nullptr) {
            return false;
        }
        if (node->data == val) {
            return true;
        } else if (val < node->data) {
            return search(node->left, val);
        } else {
            return search(node->right, val);
        }
    }

    // Inorder traversal for display
    void inorder(const Node* node) const {
        if (node == nullptr) 
            return;
        inorder(node->left);
        cout << node->data << " ";
        inorder(node->right);
    }

public:
    AVLTree() : root(nullptr) {}

    // Insert a key-value pair
    void insert(const T& k) {
        root = insert(root, k);
    }

    // Search for a key
    bool search(const T& k) const {
        return search(root, k);
    }

    // Display the tree contents
    void display() const {
        cout << "Inorder Traversal: ";
        inorder(root);
        cout << endl;
    }
};

int main() {
    AVLTree<int> avl;
    int choice, value;

    do {
        cout << "\n======AVL Tree Operations=======\n";
        cout << "1. Insert\n";
        cout << "2. Search\n";
        cout << "3. Display (Inorder)\n";
        cout << "4. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter value to insert: ";
                cin >> value;
                avl.insert(value);
                break;
            case 2:
                cout << "Enter value to search: ";
                cin >> value;
                if (avl.search(value)) {
                    cout << value << " found in the AVL tree.\n";
                } else {
                    cout << value << " not found in the AVL tree.\n";
                }
                break;
            case 3:
                avl.display();
                break;
            case 4:
                cout << "Exiting...\n";
                break;
            default:
                cout << "Invalid choice. Please try again.\n";
        }
    } while (choice != 4);

    return 0;
}